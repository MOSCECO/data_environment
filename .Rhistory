# Bathymetric threshold
BT <- ceiling(summary(sort(unlist(bathy_threshold)))[5]/10)*10
BT
# Données d'occurrences
# INVMAR
cmd <- "rsync -avuc --delete /home/borea/Documents/mosceco/r_projects/MOSCECO_L2/data_occurrences/data/tidy/occ_threshold/list_occ_thresh_nearest.rds /home/borea/Documents/mosceco/r_projects/MOSCECO_L2/data_environment/data/raw/"
system(cmd)
pa <- readRDS(
here("data", "raw", "occ_threshold", "list_occ_thresh_nearest.rds")
)
pa <- readRDS(
here("data", "raw", "list_occ_thresh_nearest.rds")
)
length(pa)
length(Os)
Os
# Relation avec la liste des espèces "cotières" et "profondes" des explorations
# du MNHN.
Os2 <- Os[names(pa)]
length(Os2)
names(pa$`Amphithrax hemphilli`)[which(names(pa$`Amphithrax hemphilli`) %in% names(Os2$`Amphithrax hemphilli`))]
names(pa$`Amphithrax hemphilli`)[which(!names(pa$`Amphithrax hemphilli`) %in% names(Os2$`Amphithrax hemphilli`))]
View(pa$`Amphithrax hemphilli`)
View(Os2$`Amphithrax hemphilli`)
g <- Os2$`Amphithrax hemphilli`
l <- pa$`Amphithrax hemphilli`
Os2 <- mapply(
\(g, l) {
# g <- Os2$`Amphithrax hemphilli`
# l <- pa$`Amphithrax hemphilli`
g$family <- l$family
g$TAX <- l$TAX
g$depth <- NA
},
Os2,
pa,
SIMPLIFY = F,
USE.NAMES = T
)
Os2 <- mapply(
\(g, l) {
# g <- Os2$`Amphithrax hemphilli`
# l <- pa$`Amphithrax hemphilli`
g$family <- rep(unique(l$family), nrow(g))
g$TAX    <- rep(unique(l$TAX), nrow(g))
g$depth  <- NA
},
Os2,
pa,
SIMPLIFY = F,
USE.NAMES = T
)
# Relation avec la liste des espèces "cotières" et "profondes" des explorations
# du MNHN.
Os2 <- Os[names(pa)]
# concaténation toutes occcurrences
names(pa$`Amphithrax hemphilli`)[
which(
!names(pa$`Amphithrax hemphilli`) %in% names(Os2$`Amphithrax hemphilli`)
)
]
Os2 <- mapply(
\(g, l) {
# g <- Os2$`Amphithrax hemphilli`
# l <- pa$`Amphithrax hemphilli`
g$family <- rep(unique(l$family), nrow(g))
g$TAX    <- rep(unique(l$TAX), nrow(g))
g$depth  <- NA
return(g)
},
Os2,
pa,
SIMPLIFY = F,
USE.NAMES = T
)
View(Os2$`Amphithrax hemphilli`)
pa2 <- sapply(
\(l) {
# l <- pa$`Amphithrax hemphilli`
l %>% select(-ISL) %>% mutate(depth = depth_MNHN)
},
simplify = F,
USE.NAMES = T
)
pa2 <- sapply(
pa,
\(l) {
# l <- pa$`Amphithrax hemphilli`
l %>% select(-ISL) %>% mutate(depth = depth_MNHN)
},
simplify = F,
USE.NAMES = T
)
View(pa2$`Amphithrax hemphilli`)
pa2 <- sapply(
pa,
\(l) {
# l <- pa$`Amphithrax hemphilli`
l <- l %>% select(-ISL)
names(l)[which(names(l) == "depth_MNHN")] <- "depth"
},
simplify = F,
USE.NAMES = T
)
View(pa2$`Amphithrax hemphilli`)
pa2 <- sapply(
pa,
\(l) {
# l <- pa$`Amphithrax hemphilli`
l <- l %>% select(-ISL)
names(l)[which(names(l) == "depth_MNHN")] <- "depth"
return(l)
},
simplify = F,
USE.NAMES = T
)
View(pa2$`Amphithrax hemphilli`)
# Relation avec la liste des espèces "cotières" et "profondes" des explorations
# du MNHN.
Os2 <- Os[names(pa)]
# concaténation toutes occcurrences
# names(pa$`Amphithrax hemphilli`)[
#   which(
#     !names(pa$`Amphithrax hemphilli`) %in% names(Os2$`Amphithrax hemphilli`)
#   )
# ]
pa2 <- sapply(
pa,
\(l) {
# l <- pa$`Amphithrax hemphilli`
l <- l %>% select(-ISL)
names(l)[which(names(l) == "depth_MNHN")] <- "depth"
return(l)
},
simplify = F,
USE.NAMES = T
)
# Relation avec la liste des espèces "cotières" et "profondes" des explorations
# du MNHN.
Os2 <- Os[names(pa)]
# concaténation toutes occcurrences
# names(pa$`Amphithrax hemphilli`)[
#   which(
#     !names(pa$`Amphithrax hemphilli`) %in% names(Os2$`Amphithrax hemphilli`)
#   )
# ]
pa2 <- sapply(
pa,
\(l) {
# l <- pa$`Amphithrax hemphilli`
l <- l %>% select(-ISL)
names(l)[which(names(l) == "depth_MNHN")] <- "depth"
return(l)
},
simplify = F,
USE.NAMES = T
)
Os2 <- mapply(
\(g, l) {
# g <- Os2$`Amphithrax hemphilli`
# l <- pa$`Amphithrax hemphilli`
g$family <- rep(unique(l$family), nrow(g))
g$TAX    <- rep(unique(l$TAX), nrow(g))
g$depth  <- NA
g <- g %>% select(all_of(names(l)))
return(g)
},
Os2,
pa2,
SIMPLIFY = F,
USE.NAMES = T
)
OO <- mapply(rbind, Os2, pa2, SIMPLIFY = F, USE.NAMES = T)
class(pa2$`Amphithrax hemphilli`)
# concaténation toutes occcurrences
# names(pa$`Amphithrax hemphilli`)[
#   which(
#     !names(pa$`Amphithrax hemphilli`) %in% names(Os2$`Amphithrax hemphilli`)
#   )
# ]
pa2 <- sapply(
pa,
\(l) {
# l <- pa$`Amphithrax hemphilli`
l <- l %>% select(-ISL)
names(l)[which(names(l) == "depth_MNHN")] <- "depth"
l_sf <- st_as_sf(
l, coords = c("decimalLongitude", "decimalLatitude"), crs = 4326
)
return(l_sf)
},
simplify = F,
USE.NAMES = T
)
Os2 <- mapply(
\(g, l) {
# g <- Os2$`Amphithrax hemphilli`
# l <- pa$`Amphithrax hemphilli`
g$family <- rep(unique(l$family), nrow(g))
g$TAX    <- rep(unique(l$TAX), nrow(g))
g$depth  <- NA
g <- g %>% select(all_of(names(l)))
return(g)
},
Os2,
pa2,
SIMPLIFY = F,
USE.NAMES = T
)
OO <- mapply(rbind, Os2, pa2, SIMPLIFY = F, USE.NAMES = T)
View(OO$`Amphithrax hemphilli`)
source("~/Documents/mosceco/r_projects/MOSCECO_L2/data_environment/scripts/boot.R", echo=TRUE)
# Import des données environnementales
s2_bottomt01 <- list.files(
here("data", "raw", "env", "copernicus", "bottomT"), full.names = T
)[1] %>%
read_stars(along = 3)
s2_bottomt <- list.files(
here("data", "raw", "env", "copernicus", "bottomT"), full.names = T
) %>%
read_stars(along = 3)
crs(gebcoast) <- "epsg:4326"
# environmental variable
database <- "copernicus"
that_var <- "so"
# occurrence
superfamily <- "Muricoidea"
species     <- "Claremontiella_nodulosa"
O <- occ[[superfamily]][[species]]
# profondeurs
gebcoast <- here(
"data", "tidy", "bathymetrie_gebco_raster", "bathymetry_gebco_raster_150m.tif"
) %>%
rast()
crs(gebcoast) <- "epsg:4326"
s2_gebcoast <- st_as_stars(gebcoast)
raster_bottomt <- s2_bottomt01
raster_bottomt <- raster_bottomt[, , , 1]
# raster_bottomt <- split(raster_bottomt, 3)
raster_bottomt <- st_as_stars(raster_bottomt)
s2_gebcoast_redim <- st_warp(s2_gebcoast, raster_bottomt)
# sélection des cellules des variables de copernicus à partir des cellules
# non-nulles de profondeur
names(s2_gebcoast_redim) <- "depth"
table(is.na(s2_gebcoast_redim["depth", ,]))
# Découpage selon les bathymétries d'intérêt
s2_bottomt_mask <- s2_bottomt
s2_bottomt_mask
s2_bottomt_mask[is.na(s2_gebcoast_redim)] <- NA
s2_bottomt_mask
s2_bottomt_mask <- st_as_stars(s2_bottomt_mask[, , , 1:10])
gc()
s2_bottomt_mask <- st_as_stars(s2_bottomt_mask[, , , 1:2])
gc()
s2_bottomt_mask <- st_as_stars(s2_bottomt_mask[, , , 1])
gc()
s2_bottomt_mask
s2_bottomt_mask <- st_as_stars(s2_bottomt_mask[, -110:-100, 10:-10, 1])
st_bbox(O)
# Découpage selon les bathymétries d'intérêt
s2_bottomt_mask <- s2_bottomt
s2_bottomt_mask[is.na(s2_gebcoast_redim)] <- NA
s2_bottomt_mask <- s2_bottomt_mask[st_bbox(O)]
s2_bottomt_mask
st_crs(s2_bottomt_mask)
st_crs(s2_bottomt) <- "EPSG:4326"
st_crs(s2_bottomt)
# Découpage selon les bathymétries d'intérêt
s2_bottomt_mask <- s2_bottomt
s2_bottomt_mask[is.na(s2_gebcoast_redim)] <- NA
s2_bottomt_mask <- s2_bottomt_mask[st_bbox(O)]
s2_bottomt_mask
s2_bottomt
s2_bottomt_mask <- s2_bottomt_mask[, , , 1]
s2_bottomt_mask
s2_bottomt_mask <- st_as_stars(s2_bottomt_mask)
# 1 # Création d'un token pour assurer la connexion entre le projet R local
#     et le repository sur GitHub.
usethis::create_github_token()
# Il faut copier le mot de passe proposé par la fenêtre ouverte après la
# commande ci-dessus dans la fonction :
gitcreds::gitcreds_set()
# 3 # Dans l'onglet "<> Code" du repository créé sur GitHub, copier le lien
#     https et le coller dans le premier argument de la fonction ci-dessous
usethis::create_from_github(
"https://github.com/iGregMan/datapaper_madibenthos_traits.git",
# Destdir : Dossier dans lequel on veut que le nouveau projet (lié au repo)
# soit copié
destdir = "/home/borea/Documents/datapaper/r_projects/MOSCECO_L2"
)
# Si erreur BAD CREDENTIALS
Sys.getenv("GITHUB_PAT")
Sys.unsetenv("GITHUB_PAT")
Sys.getenv("GITHUB_PAT")
# 3 # Dans l'onglet "<> Code" du repository créé sur GitHub, copier le lien
#     https et le coller dans le premier argument de la fonction ci-dessous
usethis::create_from_github(
"https://github.com/iGregMan/datapaper_madibenthos_traits.git",
# Destdir : Dossier dans lequel on veut que le nouveau projet (lié au repo)
# soit copié
destdir = "/home/borea/Documents/datapaper/r_projects/MOSCECO_L2"
)
# 3 # Dans l'onglet "<> Code" du repository créé sur GitHub, copier le lien
#     https et le coller dans le premier argument de la fonction ci-dessous
usethis::create_from_github(
"https://github.com/iGregMan/datapaper_madibenthos_traits.git",
# Destdir : Dossier dans lequel on veut que le nouveau projet (lié au repo)
# soit copié
destdir = "/home/borea/Documents/datapaper/"
)
# 3 # Dans l'onglet "<> Code" du repository créé sur GitHub, copier le lien
#     https et le coller dans le premier argument de la fonction ci-dessous
usethis::create_from_github(
"https://github.com/iGregMan/datapaper_madibenthos_traits.git",
# Destdir : Dossier dans lequel on veut que le nouveau projet (lié au repo)
# soit copié
destdir = "/home/borea/Documents/mosceco/datapaper"
)
ip
ip = as.data.frame(installed.packages()[,c(1,3:4)])
ip = ip[is.na(ip$Priority),1:2,drop=FALSE]
ip
source("~/Documents/mosceco/r_projects/MOSCECO_L2/data_environment/scripts/boot.R", echo=TRUE)
source("~/Documents/mosceco/r_projects/MOSCECO_L2/data_environment/scripts/home_pointer_bottomT.R", echo=TRUE)
source("~/Documents/mosceco/r_projects/MOSCECO_L2/data_environment/scripts/home_pointer_bottomT.R", echo=TRUE)
source("~/Documents/mosceco/r_projects/MOSCECO_L2/data_environment/scripts/home_pointer_bottomT.R", echo=TRUE)
path_epdv_supfam_sp
i <- 1
list.files(here(path_epdv_supfam_sp), pattern = sprintf("%03d", i)) %>%
length() == 0
i <- 500
list.files(here(path_epdv_supfam_sp), pattern = sprintf("%03d", i)) %>%
length() == 0
source("~/Documents/mosceco/r_projects/MOSCECO_L2/data_environment/scripts/home_pointer_bottomT.R", echo=TRUE)
d2 <- lapply(dt, \(x) do.call(rbind, x))
d2
dt
d
dt <- transpose(d)
dt
d
?transpose
dt <- data.table::transpose(d)
dt
d
dt <- purrr::transpose(d)
warnings()
d
d2 <- lapply(d, \(x) do.call(rbind, x))
d2
dt <- transpose(d)
dt <- data.table::transpose(d)
d[[1]]
d[[2]]
d[[3]]
d[1]
head(d)
head(d, 100)
d
d[[1]]
d[[1]][[1]]
d[[376]]
d[[376]] %>% class()
d[[1]] %>% class()
d[[376]] %>% length()
d[[376]][[1]] %>% length()
d[[376]][[1]] %>% class()
d[[1]][[1]] %>% class()
d[[29]]
d[[30]]
d[[50]]
d[[100]]
d[[150]]
d[[200]]
d[[300]]
d[[350]]
d[[340]]
d[[330]]
d[[331]]
d[[332]]
d[[333*]]
d[[333]]
d[[334]]
d[[335]]
d[[336]]
d[[337]]
here(path_epdv_supfam_sp) %>%
list.files(pattern = "env_data_point") %>%
readRDS()
data_env_pointers_ngb <- here(path_epdv_supfam_sp) %>%
list.files(pattern = "env_data_point", full.names = T) %>%
lapply(readRDS)
data_env_pointers_ngb
# occurrences qui renvoient une erreur
vecna <- which(is.na(data_env_pointers_ngb))
vecna
# réorganisation
data_per_occ_per_var <- lapply(
1:nrow(O2_sf),
\(i) {
# environnemental data linked to occurrence
# i <- 10
tv <- if (!is.na(data_env_pointers_ngb[i])) {
de_occ <- data_env_pointers_ngb[[i]]
vartime <- lapply(
de_occ,
# temporal slice of environnemental data for each occurrence
\(de_slice) {
# extract its time stamps from the stars
# de_slice <- de_occ$`copernicus_waves_2022-10-01_2022-11-01`
ttime <- (stars::st_get_dimension_values(de_slice, "time")*3600) %>%
as.POSIXct(origin = "1950-01-01")
# create one tibble per variable stored into the stars object
tbs_out <- lapply(
names(de_slice),
\(that_var) {
vvalu <- de_slice[[that_var]]
out <- tibble(
x     = O[i, "decimalLongitude"] %>%
st_drop_geometry() %>% unlist(),
y     = O[i, "decimalLatitude"]  %>%
st_drop_geometry() %>% unlist(),
time  = ttime,
value = t(vvalu)[, 1]
)
return(out)
})
names(tbs_out) <- names(de_slice)
return(tbs_out)
})
timevar <- vartime %>% transpose()
lapply(timevar, \(x) {
y <- do.call(rbind, x)
return(y[!duplicated(y), ])
})
} else {
tibble(
x     = O[i, "decimalLongitude"] %>% st_drop_geometry() %>% unlist(),
y     = O[i, "decimalLatitude"]  %>% st_drop_geometry() %>% unlist(),
time  = NA,
value = NA
) }
return(tv)
})
# Vérification
vnan <- which(
data_per_occ_per_var %>%
lapply(pluck, that_var) %>%
lapply(\(tb) unique(tb$value)) %>%
is.na()
)
table(vnan) # integer(0) ok
# climatologies MOYENNES et ÉCARTS-TYPES
d <- lapply(
1:length(data_per_occ_per_var),
\(i) {
# i <- 1
print(paste0(i, "/", length(data_per_occ_per_var)))
o <- data_per_occ_per_var[[i]]
mean_values <- if(class(o)[1] == "list") {
mean_values <- lapply(
o,
\(tb) {
# tb <- o$VHM0_WW
tb_out <- tb %>%
group_by(x, y) %>%
summarise(value_mean = mean(value), value_stdv = sd(value))
}
)
names(mean_values) <- names(o)
mean_values
} else {
list(
bottomT  = o %>% select(-time)
)
}
return(mean_values)
}
)
dt <- data.table::transpose(d)
dt <- transpose(d)
dt
d2 <- lapply(d, \(x) do.call(rbind, x))
d2$bottomT <- d2$bottomT %>% select(-value)
d2$bottomT
dt
d2 <- lapply(dt, \(x) do.call(rbind, x))
d2 <- lapply(dt, \(x) do.call(rbind, x))
d2$bottomT <- d2$bottomT %>% select(-value)
d2$bottomT
# d2$bottomT <- d2$bottomT %>% select(-value)
lapply(d2, dim)
lapply(d2, \(tb) table(duplicated(tb)))
d3 <- lapply(d2, \(x) x[!duplicated(x),] %>% na.omit())
lapply(d3, dim)
# fichier de sauvegarde
path_clim_global <- here("data", "tidy", "clim_global")
makeMyDir(path_clim_global)
path_supfam <- here(path_clim_global, superfamily)
makeMyDir(path_supfam)
path_supfam_sp <- here(path_clim_global, superfamily, species)
makeMyDir(path_supfam_sp)
# sauvegarde
lapply(
names(d2), \(n) write.csv(
d2[[n]],
here(path_supfam_sp, paste0(tolower(n), ".csv")),
row.names = F
)
)
source("~/Documents/mosceco/r_projects/MOSCECO_L2/data_environment/scripts/home_pointer_bottomT.R", echo=TRUE)
source("~/Documents/mosceco/r_projects/MOSCECO_L2/data_environment/scripts/home_pointer_bottomT.R", echo=TRUE)
